@page "/blog/blazor-static-sites"

<PageTitle>Blazor für statische Websites - Stefan Nikolei Tech Blog</PageTitle>

<article class="blog-post-content">
    <header class="post-header">
        <h1>Blazor für statische Websites</h1>
        <div class="post-meta">
            <span class="post-date">13. Juli 2025</span>
            <span class="post-category">Kategorie: Blazor, .NET</span>
        </div>
    </header>
    
    <div class="post-body">
        <p class="lead">
            Blazor WebAssembly ist nicht nur für komplexe Web-Anwendungen geeignet. 
            Es eignet sich auch hervorragend für statische Websites wie Blogs. 
            In diesem Artikel zeige ich, warum und wie.
        </p>
        
        <h2>Warum Blazor für einen Blog?</h2>
        <p>
            Auf den ersten Blick mag es übertrieben erscheinen, ein komplettes SPA-Framework 
            für einen einfachen Blog zu verwenden. Aber Blazor WebAssembly bietet einige 
            interessante Vorteile:
        </p>
        
        <h3>1. C# statt JavaScript</h3>
        <p>
            Als .NET-Entwickler kann ich meine bevorzugte Programmiersprache verwenden, 
            ohne zwischen Backend und Frontend wechseln zu müssen. Das bedeutet:
        </p>
        <ul>
            <li>Einheitliche Code-Basis</li>
            <li>Wiederverwendbare Komponenten</li>
            <li>Typsicherheit im gesamten Stack</li>
            <li>Bessere Entwickler-Produktivität</li>
        </ul>
        
        <h3>2. Komponentenbasierte Architektur</h3>
        <p>
            Blazor ermöglicht es, die Website in wiederverwendbare Komponenten zu strukturieren:
        </p>
        <pre><code>@* BlogPost.razor *@
&lt;article class="blog-post"&gt;
    &lt;h2&gt;@Title&lt;/h2&gt;
    &lt;p class="post-meta"&gt;@PublishDate.ToString("dd. MMMM yyyy")&lt;/p&gt;
    &lt;div&gt;@ChildContent&lt;/div&gt;
&lt;/article&gt;

@code {
    [Parameter] public string Title { get; set; } = "";
    [Parameter] public DateTime PublishDate { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }
}</code></pre>
        
        <h3>3. Statische Generierung mit GitHub Pages</h3>
        <p>
            Das Schöne an Blazor WebAssembly ist, dass es komplett statische Dateien generiert:
        </p>
        <ul>
            <li>HTML, CSS und JavaScript-Dateien</li>
            <li>WASM-Binaries für die .NET-Runtime</li>
            <li>Keine Server-Abhängigkeiten</li>
            <li>Perfekt für GitHub Pages</li>
        </ul>
        
        <h2>Setup und Deployment</h2>
        <p>
            Das Setup ist überraschend einfach:
        </p>
        
        <h3>1. Projekt erstellen</h3>
        <pre><code>dotnet new blazorwasm -n MeinBlog</code></pre>
        
        <h3>2. GitHub Actions für automatisches Deployment</h3>
        <p>
            Mit einer einfachen GitHub Actions Workflow-Datei lässt sich das Deployment 
            komplett automatisieren. Bei jedem Push auf den main Branch wird automatisch 
            gebaut und deployed.
        </p>
        
        <h3>3. Konfiguration für GitHub Pages</h3>
        <p>
            Wichtig ist die korrekte Konfiguration der <code>base href</code> und 
            die Behandlung von Client-Side Routing.
        </p>
        
        <h2>Vorteile gegenüber traditionellen Static Site Generators</h2>
        <p>
            Im Vergleich zu Jekyll, Hugo oder Gatsby bietet Blazor:
        </p>
        <ul>
            <li><strong>Typsicherheit</strong> - Compile-Time Checks für alle Templates</li>
            <li><strong>IntelliSense</strong> - Vollständige IDE-Unterstützung</li>
            <li><strong>Debugging</strong> - Echtes Debugging mit Breakpoints</li>
            <li><strong>Komponentenwiederverwendung</strong> - Zwischen Projekten</li>
        </ul>
        
        <h2>Nachteile und Überlegungen</h2>
        <p>
            Natürlich gibt es auch Nachteile:
        </p>
        <ul>
            <li><strong>Größe</strong> - WASM-Bundles sind größer als traditionelles HTML/JS</li>
            <li><strong>Ladezeit</strong> - Initiales Laden dauert länger</li>
            <li><strong>SEO</strong> - Erfordert Pre-Rendering für optimale Suchmaschinen-Optimierung</li>
            <li><strong>Browser-Support</strong> - WebAssembly ist relativ neu</li>
        </ul>
        
        <h2>Fazit</h2>
        <p>
            Blazor WebAssembly für einen Blog zu verwenden mag auf den ersten Blick 
            wie "Overkill" erscheinen. Aber es demonstriert eindrucksvoll die 
            Vielseitigkeit moderner .NET-Technologien und bietet eine konsistente 
            Entwicklererfahrung.
        </p>
        
        <p>
            Für .NET-Entwickler, die ihre Fähigkeiten auch im Frontend-Bereich 
            einsetzen möchten, ist es eine spannende Alternative zu traditionellen 
            Ansätzen.
        </p>
    </div>
    
    <footer class="post-footer">
        <a href="/blog" class="back-to-blog">← Zurück zur Blog-Übersicht</a>
    </footer>
</article>

<style>
    .blog-post-content {
        max-width: 800px;
        margin: 0 auto;
        line-height: 1.6;
    }
    
    .post-header {
        text-align: center;
        margin-bottom: 2rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid #e9ecef;
    }
    
    .post-header h1 {
        color: #343a40;
        margin-bottom: 1rem;
    }
    
    .post-meta {
        color: #6c757d;
        font-size: 0.9rem;
    }
    
    .post-meta span {
        margin-right: 1rem;
    }
    
    .post-body {
        margin: 2rem 0;
    }
    
    .post-body .lead {
        font-size: 1.2rem;
        color: #495057;
        margin-bottom: 2rem;
    }
    
    .post-body h2 {
        color: #343a40;
        margin-top: 2.5rem;
        margin-bottom: 1rem;
        border-bottom: 1px solid #e9ecef;
        padding-bottom: 0.5rem;
    }
    
    .post-body h3 {
        color: #495057;
        margin-top: 2rem;
        margin-bottom: 1rem;
    }
    
    .post-body ul {
        margin: 1rem 0;
        padding-left: 1.5rem;
    }
    
    .post-body li {
        margin-bottom: 0.5rem;
    }
    
    .post-body a {
        color: #007bff;
        text-decoration: none;
    }
    
    .post-body a:hover {
        text-decoration: underline;
    }
    
    .post-body pre {
        background-color: #f8f9fa;
        padding: 1rem;
        border-radius: 5px;
        overflow-x: auto;
        margin: 1rem 0;
    }
    
    .post-body code {
        background-color: #f8f9fa;
        padding: 0.2rem 0.4rem;
        border-radius: 3px;
        font-family: 'Courier New', monospace;
        font-size: 0.9rem;
    }
    
    .post-body pre code {
        background-color: transparent;
        padding: 0;
    }
    
    .post-footer {
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid #e9ecef;
    }
    
    .back-to-blog {
        color: #007bff;
        text-decoration: none;
    }
    
    .back-to-blog:hover {
        text-decoration: underline;
    }
</style>